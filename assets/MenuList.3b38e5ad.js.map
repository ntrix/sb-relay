{"version":3,"file":"MenuList.3b38e5ad.js","sources":["../../node_modules/@mui/material/MenuList/MenuList.js"],"sourcesContent":["'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"actions\", \"autoFocus\", \"autoFocusItem\", \"children\", \"className\", \"disabledItemsFocusable\", \"disableListWrap\", \"onKeyDown\", \"variant\"];\nimport * as React from 'react';\nimport { isFragment } from 'react-is';\nimport PropTypes from 'prop-types';\nimport ownerDocument from '../utils/ownerDocument';\nimport List from '../List';\nimport getScrollbarSize from '../utils/getScrollbarSize';\nimport useForkRef from '../utils/useForkRef';\nimport useEnhancedEffect from '../utils/useEnhancedEffect';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nfunction nextItem(list, item, disableListWrap) {\n  if (list === item) {\n    return list.firstChild;\n  }\n  if (item && item.nextElementSibling) {\n    return item.nextElementSibling;\n  }\n  return disableListWrap ? null : list.firstChild;\n}\nfunction previousItem(list, item, disableListWrap) {\n  if (list === item) {\n    return disableListWrap ? list.firstChild : list.lastChild;\n  }\n  if (item && item.previousElementSibling) {\n    return item.previousElementSibling;\n  }\n  return disableListWrap ? null : list.lastChild;\n}\nfunction textCriteriaMatches(nextFocus, textCriteria) {\n  if (textCriteria === undefined) {\n    return true;\n  }\n  let text = nextFocus.innerText;\n  if (text === undefined) {\n    // jsdom doesn't support innerText\n    text = nextFocus.textContent;\n  }\n  text = text.trim().toLowerCase();\n  if (text.length === 0) {\n    return false;\n  }\n  if (textCriteria.repeating) {\n    return text[0] === textCriteria.keys[0];\n  }\n  return text.indexOf(textCriteria.keys.join('')) === 0;\n}\nfunction moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {\n  let wrappedOnce = false;\n  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);\n  while (nextFocus) {\n    // Prevent infinite loop.\n    if (nextFocus === list.firstChild) {\n      if (wrappedOnce) {\n        return false;\n      }\n      wrappedOnce = true;\n    }\n\n    // Same logic as useAutocomplete.js\n    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';\n    if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {\n      // Move to the next element.\n      nextFocus = traversalFunction(list, nextFocus, disableListWrap);\n    } else {\n      nextFocus.focus();\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * A permanently displayed menu following https://www.w3.org/WAI/ARIA/apg/patterns/menu-button/.\n * It's exposed to help customization of the [`Menu`](/material-ui/api/menu/) component if you\n * use it separately you need to move focus into the component manually. Once\n * the focus is placed inside the component it is fully keyboard accessible.\n */\nconst MenuList = /*#__PURE__*/React.forwardRef(function MenuList(props, ref) {\n  const {\n      // private\n      // eslint-disable-next-line react/prop-types\n      actions,\n      autoFocus = false,\n      autoFocusItem = false,\n      children,\n      className,\n      disabledItemsFocusable = false,\n      disableListWrap = false,\n      onKeyDown,\n      variant = 'selectedMenu'\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const listRef = React.useRef(null);\n  const textCriteriaRef = React.useRef({\n    keys: [],\n    repeating: true,\n    previousKeyMatched: true,\n    lastTime: null\n  });\n  useEnhancedEffect(() => {\n    if (autoFocus) {\n      listRef.current.focus();\n    }\n  }, [autoFocus]);\n  React.useImperativeHandle(actions, () => ({\n    adjustStyleForScrollbar: (containerElement, theme) => {\n      // Let's ignore that piece of logic if users are already overriding the width\n      // of the menu.\n      const noExplicitWidth = !listRef.current.style.width;\n      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {\n        const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;\n        listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;\n        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;\n      }\n      return listRef.current;\n    }\n  }), []);\n  const handleKeyDown = event => {\n    const list = listRef.current;\n    const key = event.key;\n    /**\n     * @type {Element} - will always be defined since we are in a keydown handler\n     * attached to an element. A keydown event is either dispatched to the activeElement\n     * or document.body or document.documentElement. Only the first case will\n     * trigger this specific handler.\n     */\n    const currentFocus = ownerDocument(list).activeElement;\n    if (key === 'ArrowDown') {\n      // Prevent scroll of the page\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'ArrowUp') {\n      event.preventDefault();\n      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key === 'Home') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);\n    } else if (key === 'End') {\n      event.preventDefault();\n      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);\n    } else if (key.length === 1) {\n      const criteria = textCriteriaRef.current;\n      const lowerKey = key.toLowerCase();\n      const currTime = performance.now();\n      if (criteria.keys.length > 0) {\n        // Reset\n        if (currTime - criteria.lastTime > 500) {\n          criteria.keys = [];\n          criteria.repeating = true;\n          criteria.previousKeyMatched = true;\n        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {\n          criteria.repeating = false;\n        }\n      }\n      criteria.lastTime = currTime;\n      criteria.keys.push(lowerKey);\n      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);\n      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {\n        event.preventDefault();\n      } else {\n        criteria.previousKeyMatched = false;\n      }\n    }\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n  const handleRef = useForkRef(listRef, ref);\n\n  /**\n   * the index of the item should receive focus\n   * in a `variant=\"selectedMenu\"` it's the first `selected` item\n   * otherwise it's the very first item.\n   */\n  let activeItemIndex = -1;\n  // since we inject focus related props into children we have to do a lookahead\n  // to check if there is a `selected` item. We're looking for the last `selected`\n  // item and use the first valid item as a fallback\n  React.Children.forEach(children, (child, index) => {\n    if (! /*#__PURE__*/React.isValidElement(child)) {\n      if (activeItemIndex === index) {\n        activeItemIndex += 1;\n        if (activeItemIndex >= children.length) {\n          // there are no focusable items within the list.\n          activeItemIndex = -1;\n        }\n      }\n      return;\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (isFragment(child)) {\n        console.error([\"MUI: The Menu component doesn't accept a Fragment as a child.\", 'Consider providing an array instead.'].join('\\n'));\n      }\n    }\n    if (!child.props.disabled) {\n      if (variant === 'selectedMenu' && child.props.selected) {\n        activeItemIndex = index;\n      } else if (activeItemIndex === -1) {\n        activeItemIndex = index;\n      }\n    }\n    if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {\n      activeItemIndex += 1;\n      if (activeItemIndex >= children.length) {\n        // there are no focusable items within the list.\n        activeItemIndex = -1;\n      }\n    }\n  });\n  const items = React.Children.map(children, (child, index) => {\n    if (index === activeItemIndex) {\n      const newChildProps = {};\n      if (autoFocusItem) {\n        newChildProps.autoFocus = true;\n      }\n      if (child.props.tabIndex === undefined && variant === 'selectedMenu') {\n        newChildProps.tabIndex = 0;\n      }\n      return /*#__PURE__*/React.cloneElement(child, newChildProps);\n    }\n    return child;\n  });\n  return /*#__PURE__*/_jsx(List, _extends({\n    role: \"menu\",\n    ref: handleRef,\n    className: className,\n    onKeyDown: handleKeyDown,\n    tabIndex: autoFocus ? 0 : -1\n  }, other, {\n    children: items\n  }));\n});\nprocess.env.NODE_ENV !== \"production\" ? MenuList.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * If `true`, will focus the `[role=\"menu\"]` container and move into tab order.\n   * @default false\n   */\n  autoFocus: PropTypes.bool,\n  /**\n   * If `true`, will focus the first menuitem if `variant=\"menu\"` or selected item\n   * if `variant=\"selectedMenu\"`.\n   * @default false\n   */\n  autoFocusItem: PropTypes.bool,\n  /**\n   * MenuList contents, normally `MenuItem`s.\n   */\n  children: PropTypes.node,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * If `true`, will allow focus on disabled items.\n   * @default false\n   */\n  disabledItemsFocusable: PropTypes.bool,\n  /**\n   * If `true`, the menu items will not wrap focus.\n   * @default false\n   */\n  disableListWrap: PropTypes.bool,\n  /**\n   * @ignore\n   */\n  onKeyDown: PropTypes.func,\n  /**\n   * The variant to use. Use `menu` to prevent selected items from impacting the initial focus\n   * and the vertical alignment relative to the anchor element.\n   * @default 'selectedMenu'\n   */\n  variant: PropTypes.oneOf(['menu', 'selectedMenu'])\n} : void 0;\nexport default MenuList;"],"names":["_excluded","nextItem","list","item","disableListWrap","__name","previousItem","textCriteriaMatches","nextFocus","textCriteria","text","moveFocus","currentFocus","disabledItemsFocusable","traversalFunction","wrappedOnce","nextFocusDisabled","MenuList","React.forwardRef","props","ref","actions","autoFocus","autoFocusItem","children","className","onKeyDown","variant","other","_objectWithoutPropertiesLoose","listRef","React.useRef","textCriteriaRef","useEnhancedEffect","React.useImperativeHandle","containerElement","theme","noExplicitWidth","scrollbarSize","getScrollbarSize","ownerDocument","handleKeyDown","event","key","criteria","lowerKey","currTime","keepFocusOnCurrent","handleRef","useForkRef","activeItemIndex","React.Children","child","index","React.isValidElement","items","newChildProps","React.cloneElement","_jsx","List","_extends","MenuList$1"],"mappings":"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"}